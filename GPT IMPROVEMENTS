Approfondiamo le funzioni presenti nello script, evidenziando il loro funzionamento e i miglioramenti che potrebbero essere apportati.

1. fetch_data(ticker)
def fetch_data(ticker):
    global exchange
    bars, ticker_df = None, None
    try:
        bars = exchange.fetch_ohlcv(ticker, timeframe=f'{CANDLE_DURATION_IN_MIN}m', limit=100)
    except:
        print(f"Error in fetching data from the exchange:{ticker}")
    
    if bars is not None:
        ticker_df = pd.DataFrame(bars[:-1], columns=['at', 'open', 'high', 'low', 'close', 'vol'])
        ticker_df['Date'] = pd.to_datetime(ticker_df['at'], unit='ms')
        ticker_df['symbol'] = ticker
    return ticker_df
Funzionalità:
Descrizione: Questa funzione recupera i dati storici (OHLCV) relativi al ticker specificato (in questo caso BTC/EUR) dall'exchange utilizzando l'API di ccxt. I dati vengono poi convertiti in un DataFrame di pandas, che è una struttura di dati molto potente per l'analisi finanziaria.
Dati recuperati: Viene recuperato l'ultimo batch di candele (100 candele), dove ogni candela rappresenta un intervallo di tempo specifico, definito dalla variabile CANDLE_DURATION_IN_MIN (1 minuto in questo caso).
Miglioramenti e suggerimenti:
Gestione degli errori: Attualmente, l'errore è gestito solo con un messaggio di stampa. Sarebbe utile gestire le eccezioni in modo più specifico, ad esempio distinguendo tra errori di connessione, errori del server, o errori relativi alla richiesta di dati non validi. In caso di errore, si potrebbe implementare una logica di retry o un fallback plan.

Esempio
except ccxt.NetworkError as e:
    print(f"Network error: {str(e)}. Retrying...")
except ccxt.ExchangeError as e:
    print(f"Exchange error: {str(e)}. Check API or market status.")
Controllo dei dati ricevuti: Prima di usare i dati, potrebbe essere utile verificare se il DataFrame è vuoto o contiene valori NaN, per evitare errori a valle.

Caching o ottimizzazione delle chiamate: Se il bot richiede frequentemente gli stessi dati, potrebbe essere utile introdurre un meccanismo di caching per evitare chiamate ripetute all'API.

2. get_trade_recommendation(ticker_df)
def get_trade_recommendation(ticker_df):
    macd_result, final_result = 'WAIT', 'WAIT'

    macd, signal, hist = talib.MACD(ticker_df['close'], fastperiod=12, slowperiod=26, signalperiod=9)
    last_hist = hist.iloc[-1]
    prev_hist = hist.iloc[-2]
    
    if not np.isnan(prev_hist) and not np.isnan(last_hist):
        macd_crossover = (abs(last_hist + prev_hist)) != (abs(last_hist) + abs(prev_hist))
        if macd_crossover:
            macd_result = 'BUY' if last_hist > 0 else 'SELL'

    if macd_result != 'WAIT':
        rsi = talib.RSI(ticker_df['close'], timeperiod=14)
        last_rsi = rsi.iloc[-1]

        if last_rsi <= RSI_OVERSOLD and macd_result == 'BUY':
            final_result = 'BUY'
        elif last_rsi >= RSI_OVERBOUGHT and macd_result == 'SELL':
            final_result = 'SELL'
    
    return final_result
Funzionalità:
Descrizione: Questa funzione elabora i dati del ticker per calcolare due indicatori tecnici principali: MACD e RSI.
MACD (Moving Average Convergence Divergence): Utilizzato per rilevare tendenze rialziste o ribassiste, confronta la differenza tra due medie mobili esponenziali (EMA). Il crossover tra la linea MACD e la linea del segnale è un indicatore di potenziale cambiamento di tendenza.
RSI (Relative Strength Index): Misura la forza o debolezza del prezzo corrente rispetto ai movimenti storici. Viene utilizzato per identificare condizioni di ipercomprato o ipervenduto.
Risultato: La funzione restituisce una raccomandazione di trading (BUY, SELL o WAIT) basata sull'analisi combinata di MACD e RSI.
Miglioramenti e suggerimenti:
Migliore gestione dei segnali: Il bot attualmente fa affidamento su un semplice controllo di crossover del MACD e valori di soglia RSI. Si potrebbero aggiungere ulteriori condizioni, come filtri basati su volumi o su ulteriori indicatori (ad esempio, medie mobili semplici).

Gestione dei dati mancanti: Si assume che i dati non contengano valori nulli. Tuttavia, se ci sono valori mancanti nel DataFrame, il calcolo di MACD e RSI potrebbe restituire errori o segnali falsi. Potrebbe essere utile gestire esplicitamente eventuali dati mancanti.

Soglie dinamiche: Le soglie per RSI (25 e 75) sono statiche. Potrebbe essere interessante renderle dinamiche in base alle condizioni di mercato o alla volatilità.

Raffinamento del crossover MACD: Il controllo attuale del crossover può essere perfezionato considerando la distanza tra il MACD e la linea del segnale, per evitare falsi segnali dovuti a fluttuazioni minori.

3. execute_trade(trade_rec_type, trading_ticker)
def execute_trade(trade_rec_type, trading_ticker):
    global exchange, HOLDING_QUANTITY
    order_placed = False
    side_value = 'buy' if trade_rec_type == "BUY" else 'sell'
    
    try:
        ticker_request = exchange.fetch_ticker(trading_ticker)
        if ticker_request is not None:
            current_price = float(ticker_request['info']['last_price'])
            scrip_quantity = round(INVESTMENT_AMOUNT_PER_TRADE / current_price, 5) if trade_rec_type == "BUY" else HOLDING_QUANTITY

            order_response = exchange.create_limit_order(trading_ticker, side_value, scrip_quantity, current_price)
            HOLDING_QUANTITY = scrip_quantity if trade_rec_type == "BUY" else HOLDING_QUANTITY

            order_placed = True
    except:
        print(f"\nALERT!!! UNABLE TO COMPLETE THE ORDER.")
    
    return order_placed
Funzionalità:
Descrizione: Questa funzione esegue un ordine di acquisto o vendita sull'exchange basandosi sulla raccomandazione ricevuta (BUY o SELL). Usa un ordine limite, il che significa che il bot compra o vende solo a un prezzo specifico o migliore.
Quantità calcolata: La quantità di criptovaluta acquistata viene calcolata dividendo l'importo da investire per il prezzo corrente, mentre la quantità venduta corrisponde a ciò che il bot sta attualmente possedendo.
Miglioramenti e suggerimenti:
Ordini limite vs. ordini di mercato: Attualmente il bot usa un ordine limite, che può non essere eseguito immediatamente se il prezzo non raggiunge il livello desiderato. Potrebbe essere utile aggiungere una logica per passare da ordini limite a ordini di mercato, o almeno considerare l'aggiunta di uno "stop-loss" per proteggersi da movimenti avversi del mercato.

Gestione delle eccezioni: Il blocco try-except è molto generico. Sarebbe meglio gestire eccezioni specifiche, come errori di prezzo, problemi di connessione o errori API. Questo renderebbe il debug più semplice.

Gestione delle posizioni: La variabile HOLDING_QUANTITY viene aggiornata solo dopo un'operazione riuscita, ma non esiste un controllo esplicito per verificare che il portafoglio abbia fondi sufficienti. Dovrebbe essere implementato un controllo preliminare dei fondi disponibili prima di eseguire un'operazione.

4. run_bot_for_ticker(ccxt_ticker, trading_ticker)
def run_bot_for_ticker(ccxt_ticker, trading_ticker):
    currently_holding = False
    while 1:
        ticker_data = fetch_data(ccxt_ticker)
        if ticker_data is not None:
            trade_rec_type = get_trade_recommendation(ticker_data)
            
            if (trade_rec_type == 'BUY' and not currently_holding) or \
                    (trade_rec_type == 'SELL' and currently_holding):
                trade_successful = execute_trade(trade_rec_type, trading_ticker)
                currently_holding = not currently_holding if trade_successful else currently_holding
            
            time.sleep(CANDLE_DURATION_IN_MIN * 60)
        else:
            time.sleep(5)
Funzionalità:
Descrizione: Questa è la funzione principale del bot, che esegue in loop i passaggi:
Recupera i dati del mercato.
Elabora una raccomandazione di trading.
Esegue l'operazione se appropriato.
Controllo delle posizioni: La variabile currently_holding traccia se il bot detiene o meno una posizione attualmente, evitando di eseguire un'operazione di "BUY" quando già in possesso o di "SELL" quando non detiene nulla.
Miglioramenti e suggerimenti:
Ottimizzazione del ciclo di polling: Attualmente il bot attende un intervallo fisso tra ogni ciclo. Potrebbe essere utile introdurre un sistema di notifica più reattivo che interroghi i dati solo quando sono disponibili nuove candele.

Miglioramenti del controllo delle posizioni: Dovrebbe essere aggiunta una logica più sofisticata per la gestione delle posizioni. Ad esempio, se viene ricevuto un segnale di "BUY" e il prezzo aumenta considerevolmente, potrebbe essere implementata una logica di trailing stop o take profit.

Logging e monitoraggio: Aggiungere logging dettagliato su ogni passaggio potrebbe essere utile per monitorare il funzionamento del bot e facilitare il debug in caso di problemi.

testare le regressioni - customizzare variabili - configurare le apis da file e ambiente

Si potrebbero inserire limiti di buy (es. orario) e gli SL e i TP

